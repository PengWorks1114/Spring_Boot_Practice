了解！這是一個非常好的學習方法。我會根據這個運作流程，一步一步、耐心且詳細地為你介紹每個部分，確保你完全理解。我們從使用者發出請求開始。

-----

### **運作流程介紹：第一步**

### **使用者發出請求**

當你在瀏覽器中輸入 `http://localhost:8080/` 並按下 Enter 時，你的電腦會向一個特定的地址發送一個「請求」。

這個地址由兩個部分組成：

* **`localhost`**：代表「本機」，也就是你的電腦。
* **`8080`**：代表一個「埠號」（Port）。你可以把它想像成是你的電腦上的一個房間號碼。

當你啟動 Spring Boot 應用程式時，它會在你的電腦上「監聽」（listening）這個 `8080` 埠號。所以當瀏覽器發出請求時，Spring Boot 應用程式就會收到它。

### **Java 程式碼如何接收這個請求？**

你的 Spring Boot 專案有一個核心的入口點，就是 `HealthInfoServiceApplication.java`。這個檔案裡有一個 `main` 方法，當你執行 `mvn spring-boot:run` 時，就是這個方法讓應用程式啟動並開始監聽。

**`src/main/java/com/example/health_info_service/HealthInfoServiceApplication.java`**

```java
package com.example.health_info_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HealthInfoServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(HealthInfoServiceApplication.class, args);
    }
}
```

這段程式碼看起來很簡單，但它做了很多事：

* **`@SpringBootApplication`**：這是一個非常重要的註解（Annotation）。它告訴 Spring Boot 這是主要的啟動類別，並且它包含了以下三個註解的功能：
    1.  `@EnableAutoConfiguration`：自動設定，Spring Boot 會根據你的相依性（例如 `spring-boot-starter-web`）自動配置好一切，包括內建的網頁伺服器（Tomcat）。
    2.  `@ComponentScan`：組件掃描，Spring Boot 會自動掃描同一個套件（`com.example.health_info_service`）及其子套件中的所有 Spring 組件（例如 `@RestController`、`@Component` 等）。
    3.  `@Configuration`：將此類別標記為設定類別。
* **`public static void main(String[] args)`**：這是所有 Java 程式的標準入口點。
* **`SpringApplication.run(HealthInfoServiceApplication.class, args)`**：這行程式碼啟動了整個 Spring Boot 應用程式。它會啟動內嵌的 Tomcat 伺服器，並開始監聽 `8080` 埠號，等待來自使用者的請求。

-----

### **小結**

總而言之，第一步的運作流程，就是當你執行 `mvn spring-boot:run` 時，你的 Java 程式就會啟動一個伺服器，並準備好隨時接收來自瀏覽器的請求。


我們繼續。現在，你的 Spring Boot 應用程式已經啟動並在 `8080` 埠號上監聽了。當瀏覽器向 `/` 路徑發出請求時，應用程式是如何將 `index.html` 傳送回去的呢？

---

### **運作流程介紹：第二步**

### **提供靜態資源**

Spring Boot 內建了一個功能，可以自動處理靜態檔案（例如 HTML、CSS、JavaScript 檔案）。你不需要寫任何 Java 程式碼來告訴它「請提供這個檔案」。

這個功能的關鍵在於**檔案存放的路徑**。Spring Boot 會自動尋找你的專案中以下幾個預設目錄下的靜態檔案：

* `src/main/resources/static/`
* `src/main/resources/public/`
* `src/main/resources/webjars/`

你的 `index.html` 檔案就放在 `src/main/resources/static/` 這個目錄下。

當你的應用程式收到來自 `http://localhost:8080/` 的請求時，它會按照以下步驟運作：

1.  **檢查請求路徑**：Spring Boot 路由器（Router）會檢查請求路徑是否與任何已定義的 API 路由（例如 `/health` 或 `/info`）相符。
2.  **尋找靜態檔案**：如果請求路徑沒有匹配到任何 API，Spring Boot 會自動去 `src/main/resources/static/` 目錄下尋找與請求路徑相符的檔案。
3.  **找到 `index.html`**：當請求路徑是 `/`（根路徑）時，Spring Boot 會自動將其對應到 `index.html` 這個檔案。
4.  **傳送回應**：Spring Boot 會將 `index.html` 檔案的內容，作為一個 HTTP 回應傳送給瀏覽器。

**`src/main/resources/static/index.html`**

這就是我們前端的檔案。它包含三個部分：
* `<head>`：載入 Bootstrap 樣式，讓頁面看起來更美觀。
* `<body>`：包含頁面的所有視覺元素（標題、按鈕、卡片等）。
* `<script>`：包含所有的 JavaScript 程式碼，這些程式碼負責處理後續的 API 請求與頁面更新。

---

### **小結**

第二步的運作流程，就是 Spring Boot 利用其內建的靜態資源服務功能，自動將你放在 `src/main/resources/static` 目錄下的 `index.html` 檔案提供給瀏覽器。這個過程是自動化的，不需要你撰寫任何額外的 Java 程式碼。

好的，我們繼續。現在，你已經知道 Spring Boot 如何將 `index.html` 傳送給瀏覽器了。接下來，我們來看看瀏覽器拿到這個檔案之後，發生了什麼事。

-----

### **運作流程介紹：第三步**

### **前端 JavaScript 運作**

當瀏覽器收到 `index.html` 的內容後，它會從上到下解析這個檔案。當它解析到 `<script>` 標籤時，它會立即執行裡面的 JavaScript 程式碼。

在我們的 `index.html` 檔案中，最底部的 `<script>` 區塊就是整個前端邏輯的所在地。

**`index.html` 檔案中的 JavaScript 程式碼**

```javascript
// ... 其他函式 ...

// 綁定「重新整理」按鈕的點擊事件
document.getElementById('btnRefresh').addEventListener('click', load);

// 在頁面載入時，立即執行 load() 函式
load();
```

這兩行程式碼是整個前端互動的起點：

1.  **`load()` 函式**：這是我們核心的函式，它包含了向後端發送 API 請求的所有邏輯。
2.  **`addEventListener('click', load)`**：這行程式碼將 `load()` 函式與 `btnRefresh` 按鈕（也就是「重新整理」按鈕）的點擊事件綁定在一起。當使用者點擊這個按鈕時，`load()` 函式就會被呼叫。
3.  **`load()`**：這行程式碼會在頁面載入完成後，立即自動執行 `load()` 函式。

### **`load()` 函式內部發生了什麼？**

`load()` 函式是異步的（`async`），它會同時執行兩個主要動作：

1.  **呼叫 `/health` API**：

    ```javascript
    const h = await fetchJson('/health');
    ```

    * `fetchJson('/health')` 函式會向你的 Spring Boot 應用程式發出一個 `GET /health` 的請求。
    * `await` 關鍵字會讓程式碼在這裡「暫停」，等待後端回傳回應。
    * 當後端回傳 `{"status":"UP"}` 這個 JSON 物件後，它會被儲存在變數 `h` 中。
    * 接著，程式碼會根據 `h.status` 的值來更新畫面上健康徽章（badge）的顏色和文字。

2.  **呼叫 `/info` API**：

    ```javascript
    const info = await fetchJson('/info');
    ```

    * `fetchJson('/info')` 函式會向後端發出 `GET /info` 的請求。
    * 程式碼同樣會等待後端回傳類似 `{"name": "...", "version": "...", "buildTime": "..."}` 的 JSON 物件。
    * 當回應傳回後，程式碼會從 `info` 物件中取出 `name`、`version` 和 `buildTime` 的值，並將它們顯示在畫面的對應位置。

-----

### **小結**

第三步的運作流程，就是瀏覽器在收到 `index.html` 後，透過內部的 JavaScript 腳本，主動向後端發出兩個 API 請求 (`/health` 和 `/info`)，並根據後端回傳的 JSON 資料來動態更新頁面的內容。這個過程實現了前後端的互動。

我們繼續。現在，你已經知道前端的 JavaScript 如何發出 `/health` 和 `/info` 的請求。接下來，我們將回到後端，看 Spring Boot 是如何處理這些請求的。

-----

### **運作流程介紹：第四步**

### **後端 API 處理請求**

在 Spring Boot 中，負責處理 HTTP 請求的類別被稱為 **Controller**。你的專案中有兩個控制器：`HealthController` 和 `InfoController`。

當一個 HTTP 請求到達 Spring Boot 應用程式時，它會交由一個名為 **DispatcherServlet** 的核心元件處理。這個元件就像一個交通警察，它會查看請求的 URL 路徑，並將其導向正確的控制器。

### **處理 `/health` 請求**

當 DispatcherServlet 看到請求路徑是 `/health` 時，它會將請求導向 `HealthController`。

**`src/main/java/com/example/health_info_service/controller/HealthController.java`**

```java
package com.example.health_info_service.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.Map;

@RestController
@RequestMapping("/health")
public class HealthController {

    @GetMapping
    public Map<String, String> health() {
        return Map.of("status", "UP");
    }
}
```

這段程式碼的關鍵點在於：

* **`@RestController`**：這個註解告訴 Spring 這是一個處理 HTTP 請求的控制器，並且會直接回傳 JSON 或 XML 格式的資料。
* **`@RequestMapping("/health")`**：這個註解將整個類別與 `/health` 這個 URL 路徑綁定在一起。所有以 `/health` 開頭的請求都會被這個控制器處理。
* **`@GetMapping`**：這是一個方法層級的註解，它表示這個方法會處理 `GET` 請求。因為類別已經設定了 `@RequestMapping("/health")`，所以這個方法處理的完整路徑是 `/health`。
* **`public Map<String, String> health()`**：
    * `Map<String, String>` 是 Java 的一個資料結構，用來儲存鍵值對（Key-Value）。
    * `return Map.of("status", "UP")` 這行程式碼創建了一個新的 `Map`，裡面只有一個鍵 `status` 和一個值 `UP`。
    * 當這個方法執行完成後，Spring Boot 會自動將這個 `Map` 轉換成一個 JSON 字串 `{"status": "UP"}`，並將其作為 HTTP 回應的內容傳送給前端。

### **處理 `/info` 請求**

同樣地，當 DispatcherServlet 看到請求路徑是 `/info` 時，它會將請求導向 `InfoController`。

**`src/main/java/com/example/health_info_service/controller/InfoController.java`**

```java
package com.example.health_info_service.controller;

import com.example.health_info_service.model.InfoResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/info")
@RequiredArgsConstructor
public class InfoController {

    @Value("${app.name}")
    private String name;
    @Value("${app.version}")
    private String version;
    @Value("${app.buildTime}")
    private String buildTime;

    @GetMapping
    public InfoResponse info() {
        if (name == null || version == null || buildTime == null) {
            throw new IllegalStateException("Config missing");
        }
        return new InfoResponse(name, version, buildTime);
    }
}
```

* **`@Value`**：這是 Spring 的一個註解，它會從設定檔（`application.yml`）中讀取對應的屬性值，並將其注入（inject）到這個類別的變數中。例如，`@Value("${app.name}")` 會讀取 `application.yml` 中 `app.name` 的值。
* **`public InfoResponse info()`**：
    * `InfoResponse` 是一個自訂的資料類別，位於 `model` 套件下，它代表了 `/info` 回應的資料格式。
    * `new InfoResponse(name, version, buildTime)` 這行程式碼創建了一個新的 `InfoResponse` 物件，並將從設定檔中讀取到的值傳遞給它。
    * Spring Boot 同樣會自動將這個 `InfoResponse` 物件轉換成一個 JSON 字串，並作為 HTTP 回應回傳給前端。

-----

### **小結**

第四步的運作流程，就是 Spring Boot 根據請求的 URL 路徑，將請求分派給對應的 Controller。Controller 中的方法負責處理請求並回傳資料，Spring Boot 會自動將 Java 物件轉換為 JSON 格式的回應，再傳送給瀏覽器。

我們繼續。現在，我們已經完成了後端 API 的介紹，你了解了後端如何根據前端的請求回傳 JSON 資料。最後一步，我們回到前端，看這些資料是如何讓頁面「活」起來的。

-----

### **運作流程介紹：第五步**

### **前端更新畫面**

當前端的 JavaScript 腳本（在第三步中發出請求）收到後端 API 回傳的 JSON 資料後，它會執行接下來的程式碼，並更新網頁的內容。這個過程就是我們所說的「動態渲染」。

讓我們再次回到 `index.html` 檔案中的 `<script>` 區塊，聚焦於 `load()` 函式。

**處理 `/health` 回應**

```javascript
// Health
clearError('healthError');
try {
  const h = await fetchJson('/health');
  document.getElementById('healthJson').textContent = JSON.stringify(h, null, 2);
  const badge = document.getElementById('healthBadge');
  if (h.status === 'UP') {
    badge.className = 'badge text-bg-success';
    badge.textContent = 'UP';
  } else {
    badge.className = 'badge text-bg-secondary';
    badge.textContent = h.status || '-';
  }
} catch (e) {
  setError('healthError', e);
  const badge = document.getElementById('healthBadge');
  badge.className = 'badge text-bg-secondary';
  badge.textContent = 'DOWN';
}
```

這段程式碼做了幾件事：

1.  **`clearError('healthError')`**：首先清除任何舊的錯誤訊息，讓畫面保持整潔。
2.  **`const h = await fetchJson('/health')`**：等待後端回傳 `{"status": "UP"}` 這個 JSON 物件，並將其賦值給 `h` 變數。
3.  **`document.getElementById('healthJson').textContent = ...`**：找到 HTML 中 `id` 為 `healthJson` 的 `<pre><code>` 標籤，然後將 `h` 物件轉換成格式化後的 JSON 字串，並顯示在裡面。
4.  **`if (h.status === 'UP')`**：檢查 `h` 物件中的 `status` 屬性。
    * 如果狀態是 `"UP"`，則將健康徽章的 CSS 類別（`className`）設定為 `text-bg-success`，這會讓它變成綠色。同時，將文字內容設為 `"UP"`。
    * 如果不是 `"UP"`，則將 CSS 類別設為 `text-bg-secondary`（灰色），並顯示回傳的狀態文字。
5.  **`catch (e)`**：如果 `fetchJson` 函式失敗（例如後端伺服器沒啟動），則會執行 `catch` 區塊，顯示錯誤訊息並將徽章設為「DOWN」。

**處理 `/info` 回應**

```javascript
// Info
clearError('infoError');
try {
  const info = await fetchJson('/info');
  document.getElementById('infoJson').textContent = JSON.stringify(info, null, 2);
  document.getElementById('name').textContent = info.name ?? '-';
  document.getElementById('version').textContent = info.version ?? '-';
  document.getElementById('buildTime').textContent = info.buildTime ?? '-';
  document.getElementById('buildTimeHuman').textContent = humanizeUtc(info.buildTime);
} catch (e) {
  setError('infoError', e);
}
```

這段程式碼的邏輯與處理 `/health` 類似：

1.  **`const info = await fetchJson('/info')`**：等待後端回傳類似 `{"name": "...", "version": "...", ...}` 的 JSON 物件。
2.  **`document.getElementById('name').textContent = info.name ?? '-';`**：這行程式碼非常重要。它會找到 HTML 中 `id` 為 `name` 的 `<span>` 標籤，然後將 `info` 物件中的 `name` 屬性值作為它的文字內容。`?? '-'` 則是一個簡單的檢查，如果 `info.name` 不存在，就顯示一個 `-`。
3.  同樣地，`version` 和 `buildTime` 的值也會以相同的方式被提取並顯示在畫面上。`humanizeUtc(info.buildTime)` 函式會將 ISO 格式的時間轉換成更易讀的本地時間。

-----

### **小結**

第五步的運作流程，就是前端的 JavaScript 負責將從後端獲取的 JSON 資料「注入」到 HTML 頁面的特定位置。透過這種方式，網頁不需要重新載入，就可以動態地更新內容，從而提供更流暢的使用者體驗。

`index.html` 檔案，詳細解說畫面上的每一個主要物件。

-----

### **前端畫面物件意義與結構**

整個頁面使用了 **Bootstrap 5** 這個前端框架來設計樣式，所以你看到的所有 `class` 屬性（例如 `container`, `card`, `d-flex`）都與 Bootstrap 的樣式有關。

#### **1. 整體佈局**

```html
<div class="container py-4">
    </div>
```

* `container`: 這是一個 Bootstrap 的類別，用來建立一個固定寬度、居中的主要內容區塊。
* `py-4`: 也是 Bootstrap 的類別，表示在垂直方向（y-axis）上提供 4 個單位（`p` 代表 padding）的內距。

#### **2. 頁面標題與按鈕區**

```html
<div class="d-flex justify-content-between align-items-center mb-3">
    <h1 class="h3 mb-0">Health & Info</h1>
    <div class="btn-group">
        <a class="btn btn-outline-secondary" href="/swagger" target="_blank">開啟 Swagger</a>
        <button id="btnRefresh" class="btn btn-primary">重新整理</button>
    </div>
</div>
```

* `h1 class="h3"`: 顯示頁面標題「Health & Info」。使用 `h3` 類別讓 `h1` 標籤的字體大小看起來像 `h3`。
* `btn-group`: Bootstrap 類別，用來將多個按鈕放在一起。
* `a`: 這是 HTML 的超連結標籤。
    * `href="/swagger"`: 點擊後會導向 `/swagger` 路徑，也就是 Swagger UI 的頁面。
    * `target="_blank"`: 告訴瀏覽器在新視窗或新分頁中開啟這個連結。
* `button id="btnRefresh"`: 這是「重新整理」按鈕。
    * `id="btnRefresh"`: 這是一個唯一的標識符（ID），在 JavaScript 程式碼中，我們使用 `document.getElementById('btnRefresh')` 來找到這個按鈕，並為它設定點擊事件。

#### **3. 健康狀態區塊**

```html
<div class="col-12 col-lg-6">
    <div class="card shadow-sm">
        <div class="card-body">
            <span id="healthBadge" class="badge text-bg-secondary">-</span>
            <pre class="mt-2"><code id="healthJson">{}</code></pre>
            <div id="healthError" class="alert alert-danger d-none mt-2"></div>
        </div>
    </div>
</div>
```

* `div class="card"`: Bootstrap 的卡片元件，用來將相關的資訊包裝在一起，並帶有邊框和陰影。
* `span id="healthBadge"`: 健康狀態徽章。
    * `id="healthBadge"`: 在 JavaScript 中用來獲取這個元素。
    * `class="badge"`: Bootstrap 的徽章類別。
    * `text-bg-secondary`: 預設的徽章樣式，灰色背景。當 API 回傳 `UP` 時，JavaScript 會將它換成 `text-bg-success`（綠色）。
* `pre` 和 `code` 標籤:
    * `pre`: 預格式化文本，它會保留空格和換行。
    * `code`: 程式碼區塊。
    * `id="healthJson"`: JavaScript 用來把從 `/health` API 獲取的 JSON 資料填入這個區塊。
* `div id="healthError"`: 錯誤訊息區塊。
    * `id="healthError"`: JavaScript 用來將錯誤訊息寫入這個區塊。
    * `class="d-none"`: Bootstrap 類別，代表 `display: none;`，也就是預設隱藏。當發生錯誤時，JavaScript 會移除這個類別，讓錯誤訊息顯示出來。

#### **4. 版本資訊區塊**

```html
<div class="col-12 col-lg-6">
    <div class="card shadow-sm">
        <div class="card-body">
            <div><strong>name：</strong><span id="name">-</span></div>
            <div><strong>version：</strong><span id="version">-</span></div>
            <div><strong>buildTime：</strong><span id="buildTime">-</span>
                <small class="text-muted">（<span id="buildTimeHuman">-</span>）</small>
            </div>
            <pre class="mt-2"><code id="infoJson">{}</code></pre>
            <div id="infoError" class="alert alert-danger d-none mt-2"></div>
        </div>
    </div>
</div>
```

* `span id="name"`、`span id="version"`、`span id="buildTime"`：這些都是用來顯示從 `/info` API 獲取的值的 `<span>` 標籤。JavaScript 會找到這些 ID，並更新它們的文字內容。
* `span id="buildTimeHuman"`: 用來顯示經過 `humanizeUtc` 函式處理後的、人類易讀的建置時間。
* `pre` 和 `code` 標籤：
    * `id="infoJson"`: JavaScript 用來把 `/info` API 獲取的 JSON 資料格式化後顯示在這裡。
* `div id="infoError"`: 與 `healthError` 類似，用於在 API 失敗時顯示錯誤訊息。

-----

