# 基本設計書｜Confidential Password Generator

## 1. 概要

* **專案名稱**：Confidential Password Generator
* **目的**：提供一個以服務層與參數物件為核心的隨機密碼產生 API 與簡易前端。
* **核心功能**：

  * 端點：`POST /passwords`
  * 請求：`{ length, digits, symbols }`
  * 回應：`{ password }`（單一組隨機密碼）
  * 驗收：長度邊界 `6 ≤ length ≤ 64`
  * 延伸選項：`excludeAmbiguous`（不含易混淆字）

## 2. 範圍

* **後端**：Java 17、Spring Boot、REST API、OpenAPI 定義。
* **前端**：純 HTML + Bootstrap + 原生 JS（不依賴框架）。
* **資料庫**：無（純計算）。
* **非功能性**：使用 `SecureRandom`、不記錄明文密碼、快速回應（< 50ms/請求於本機開發環境）。

## 3. 系統構成

* **API 層（Controller）**：接收/驗證請求 → 呼叫服務 → 組裝回應。
* **服務層（Service）**：依策略物件 `PasswordPolicy` 產生密碼。
* **參數物件（DTO/Policy）**：`PasswordRequest`、`PasswordPolicy`、`PasswordResponse`。
* **共用（Util）**：字元池、洗牌、強隨機。
* **前端**：`index.html`（表單 + 顯示結果 + Copy 按鈕 + 強度條）。

## 4. 字元規格

* **基本字母**（預設必含）：`a–z`、`A–Z`
* **數字**（`digits=true` 時加入池並保證至少 1 個）：`0–9`
* **符號**（`symbols=true` 時加入池並保證至少 1 個）：建議集合

  ```
  ! @ # $ % ^ & * ( ) - _ = + [ ] { } ; : , . ? 
  ```
* **易混淆字集合**（`excludeAmbiguous=true` 時移除）：

  ```
  0 O o 1 l I 5 S 2 Z 8 B | / \ ' " ` ~ < >
  ```

  註：此集合可在程式以常數集中維護，後續可調整。

## 5. 請求與回應設計

### 5.1 端點

* **Method/Path**：`POST /passwords`
* **Content-Type**：`application/json`

### 5.2 請求（Request）

```json
{
  "length": 12,
  "digits": true,
  "symbols": true,
  "excludeAmbiguous": false
}
```

* `length`：整數，必填，`6–64`。
* `digits`：布林，選填，預設 `true`。
* `symbols`：布林，選填，預設 `true`。
* `excludeAmbiguous`：布林，選填，預設 `false`。

### 5.3 回應（Response）

```json
{
  "password": "A8f!mZpQ1@tc"
}
```

### 5.4 錯誤回應格式

```json
{
  "timestamp": "2025-08-28T06:10:00Z",
  "path": "/passwords",
  "error": "VALIDATION_ERROR",
  "message": "length must be between 6 and 64"
}
```

## 6. 驗證規則

1. `length` 未提供或非整數 → 400。
2. `length < 6` 或 `> 64` → 400。
3. 字元池經過 `excludeAmbiguous` 過濾後仍需包含 **字母**；否則 422。
4. 若 `digits=true` → 產生結果需至少 1 位數字；`symbols=true` 同理。
5. 使用 `SecureRandom`；不可使用 `Math.random()`。

## 7. 產生算法（服務層）

1. 根據參數建立**字元池**：

   * 起始：`lettersLower + lettersUpper`
   * 若 `digits=true`：加入 `digitsSet`
   * 若 `symbols=true`：加入 `symbolsSet`
   * 若 `excludeAmbiguous=true`：從池中剔除 `ambiguousSet`
2. **保證性抽取**：

   * 固定先各抽 1 個（對應勾選的類別：數字/符號），再以字元池補足至 `length`。
3. **洗牌**：Fisher–Yates 以 `SecureRandom` 打散順序。
4. 輸出字串。

## 8. 前端介面規劃

### 8.1 互動流程

* 使用者調整長度（Range 6–64）、勾選 **包含數字**、**包含符號**、**不含易混淆字**。
* 按下「產生密碼」→ 呼叫 `POST /passwords` → 顯示密碼。
* 提供「一鍵複製」與「強度指標（簡易）」：以長度與類別數估算（僅供參考）。

### 8.2 版面（Wireframe）

* **上方卡片**：選項表單（Length、Digits、Symbols、Exclude Ambiguous、Generate）
* **中間卡片**：輸出框（唯讀）+ Copy 按鈕
* **下方**：強度條（弱/中/強）與提示訊息（如長度建議 ≥ 12）

### 8.3 HTML（示意，可直接使用）

```html
<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <title>Confidential Password Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">
<div class="container py-4">
  <h1 class="mb-3">Confidential Password Generator</h1>

  <div class="card mb-3">
    <div class="card-body">
      <form id="form">
        <div class="row g-3 align-items-center">
          <div class="col-md-4">
            <label for="length" class="form-label">長度（6–64）</label>
            <input type="range" class="form-range" id="length" min="6" max="64" value="12" oninput="lenOut.innerText=this.value">
            <div>目前長度：<span id="lenOut">12</span></div>
          </div>
          <div class="col-md-8">
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="digits" checked>
              <label class="form-check-label" for="digits">包含數字</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="symbols" checked>
              <label class="form-check-label" for="symbols">包含符號</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="excludeAmbiguous">
              <label class="form-check-label" for="excludeAmbiguous">不含易混淆字</label>
            </div>
          </div>
        </div>
        <div class="mt-3">
          <button id="btnGen" type="submit" class="btn btn-primary">產生密碼</button>
        </div>
      </form>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-body d-flex gap-2">
      <input id="output" class="form-control" type="text" placeholder="尚未產生" readonly>
      <button id="btnCopy" class="btn btn-outline-secondary" type="button">複製</button>
    </div>
    <div class="card-footer">
      <div class="progress" role="progressbar" aria-label="strength" aria-valuemin="0" aria-valuemax="100">
        <div id="strengthBar" class="progress-bar" style="width: 0%"></div>
      </div>
      <small id="strengthHint" class="text-muted">建議長度 ≥ 12 且同時包含數字與符號。</small>
    </div>
  </div>

  <div id="alert" class="alert d-none" role="alert"></div>
</div>

<script>
const apiBase = '/passwords';
const $ = (id)=>document.getElementById(id);
const alertBox = $('alert');

function setAlert(msg, type='danger'){
  alertBox.className = 'alert alert-' + type;
  alertBox.textContent = msg;
}

function clearAlert(){
  alertBox.className = 'alert d-none';
  alertBox.textContent = '';
}

function strengthScore(pwd, digits, symbols){
  if(!pwd) return 0;
  let classes = 1; // letters
  if(digits) classes++;
  if(symbols) classes++;
  const len = pwd.length;
  // 粗略評分：長度權重 + 類別權重
  return Math.min(100, Math.round((len/64)*70 + (classes/3)*30));
}

$('form').addEventListener('submit', async (e)=>{
  e.preventDefault(); clearAlert();
  const body = {
    length: parseInt($('length').value,10),
    digits: $('digits').checked,
    symbols: $('symbols').checked,
    excludeAmbiguous: $('excludeAmbiguous').checked
  };
  try{
    const res = await fetch(apiBase, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(body)
    });
    if(!res.ok){
      const err = await res.json().catch(()=>({message: res.statusText}));
      setAlert(err.message || '產生失敗'); return;
    }
    const data = await res.json();
    $('output').value = data.password;
    const score = strengthScore(data.password, body.digits, body.symbols);
    $('strengthBar').style.width = score + '%';
    $('strengthHint').textContent = score < 40 ? '強度：弱' : (score < 70 ? '強度：中' : '強度：強');
  }catch(ex){
    setAlert('網路或伺服器錯誤，請稍後再試。');
  }
});

$('btnCopy').addEventListener('click', async ()=>{
  const val = $('output').value;
  if(!val){ setAlert('尚未有可複製的密碼','warning'); return; }
  await navigator.clipboard.writeText(val);
  setAlert('已複製到剪貼簿','success');
});
</script>
</body>
</html>
```

## 9. 後端類別設計（Java/Spring Boot）

### 9.1 DTO / Policy

```java
// PasswordRequest.java
public record PasswordRequest(
    Integer length,
    Boolean digits,
    Boolean symbols,
    Boolean excludeAmbiguous
) {}
// 預設處理可在 Controller 內補：digits/symbols 預設 true，excludeAmbiguous 預設 false

// PasswordResponse.java
public record PasswordResponse(String password) {}
```

```java
// PasswordPolicy.java
public final class PasswordPolicy {
  public final int length;
  public final boolean includeDigits;
  public final boolean includeSymbols;
  public final boolean excludeAmbiguous;

  public PasswordPolicy(int length, boolean includeDigits, boolean includeSymbols, boolean excludeAmbiguous) {
    this.length = length;
    this.includeDigits = includeDigits;
    this.includeSymbols = includeSymbols;
    this.excludeAmbiguous = excludeAmbiguous;
  }
}
```

### 9.2 Service

```java
// PasswordGeneratorService.java
public interface PasswordGeneratorService {
  String generate(PasswordPolicy policy);
}
```

```java
// PasswordGeneratorServiceImpl.java
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

public class PasswordGeneratorServiceImpl implements PasswordGeneratorService {
  private static final char[] LOWER = "abcdefghijklmnopqrstuvwxyz".toCharArray();
  private static final char[] UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
  private static final char[] DIGITS = "0123456789".toCharArray();
  private static final char[] SYMBOLS = "!@#$%^&*()-_=+[]{};:,.?".toCharArray();
  private static final char[] AMBIG = "0Oo1lI5S2Z8B|/\\'\"`~<>".toCharArray();

  private final SecureRandom rnd = new SecureRandom();

  @Override
  public String generate(PasswordPolicy p) {
    if (p.length < 6 || p.length > 64) throw new IllegalArgumentException("length must be between 6 and 64");

    List<Character> pool = new ArrayList<>();
    addAll(pool, LOWER); addAll(pool, UPPER);
    if (p.includeDigits) addAll(pool, DIGITS);
    if (p.includeSymbols) addAll(pool, SYMBOLS);

    if (p.excludeAmbiguous) removeAll(pool, AMBIG);

    // 確保尚有字母存在
    boolean hasLetter = pool.stream().anyMatch(ch -> Character.isLetter(ch));
    if (!hasLetter) throw new IllegalStateException("character pool must contain letters");

    List<Character> result = new ArrayList<>(p.length);

    // 保證類別（若有啟用）
    if (p.includeDigits) result.add(pickFrom(DIGITS, p.excludeAmbiguous));
    if (p.includeSymbols) result.add(pickFrom(SYMBOLS, p.excludeAmbiguous));

    // 補足
    while (result.size() < p.length) {
      result.add(pool.get(rnd.nextInt(pool.size())));
    }
    // 洗牌
    for (int i = result.size() - 1; i > 0; i--) {
      int j = rnd.nextInt(i + 1);
      char tmp = result.get(i);
      result.set(i, result.get(j));
      result.set(j, tmp);
    }
    StringBuilder sb = new StringBuilder(p.length);
    result.forEach(sb::append);
    return sb.toString();
  }

  private static void addAll(List<Character> list, char[] arr) { for (char c : arr) list.add(c); }

  private static void removeAll(List<Character> list, char[] arr) {
    for (char c : arr) list.removeIf(x -> x == c);
  }

  private char pickFrom(char[] arr, boolean excludeAmbig) {
    // 若排除易混淆字，先過濾
    if (excludeAmbig) {
      List<Character> filtered = new ArrayList<>();
      outer: for (char c : arr) {
        for (char a : AMBIG) if (c == a) { continue outer; }
        filtered.add(c);
      }
      if (filtered.isEmpty()) throw new IllegalStateException("no chars available after excluding ambiguous");
      return filtered.get(rnd.nextInt(filtered.size()));
    }
    return arr[rnd.nextInt(arr.length)];
  }
}
```

### 9.3 Controller

```java
// PasswordController.java
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/passwords")
public class PasswordController {

  private final PasswordGeneratorService service;

  public PasswordController(PasswordGeneratorService service) { this.service = service; }

  @PostMapping
  public ResponseEntity<PasswordResponse> generate(@RequestBody PasswordRequest req) {
    int length = (req.length() == null) ? 12 : req.length();
    boolean digits = (req.digits() == null) ? true : req.digits();
    boolean symbols = (req.symbols() == null) ? true : req.symbols();
    boolean excludeAmbiguous = (req.excludeAmbiguous() == null) ? false : req.excludeAmbiguous();

    PasswordPolicy policy = new PasswordPolicy(length, digits, symbols, excludeAmbiguous);
    String pwd = service.generate(policy);
    return ResponseEntity.ok(new PasswordResponse(pwd));
  }
}
```

### 9.4 例外處理（全域）

```java
// GlobalExceptionHandler.java
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import jakarta.servlet.http.HttpServletRequest;
import java.time.Instant;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(IllegalArgumentException.class)
  public ResponseEntity<Map<String,Object>> handleBadRequest(IllegalArgumentException ex, HttpServletRequest req){
    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of(
      "timestamp", Instant.now().toString(),
      "path", req.getRequestURI(),
      "error", "VALIDATION_ERROR",
      "message", ex.getMessage()
    ));
  }

  @ExceptionHandler(IllegalStateException.class)
  public ResponseEntity<Map<String,Object>> handleUnprocessable(IllegalStateException ex, HttpServletRequest req){
    return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(Map.of(
      "timestamp", Instant.now().toString(),
      "path", req.getRequestURI(),
      "error", "UNPROCESSABLE",
      "message", ex.getMessage()
    ));
  }
}
```

## 10. OpenAPI（YAML 摘要）

```yaml
openapi: 3.0.3
info:
  title: Confidential Password Generator API
  version: 1.0.0
paths:
  /passwords:
    post:
      summary: Generate a random password
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                length: { type: integer, minimum: 6, maximum: 64, example: 12 }
                digits: { type: boolean, default: true }
                symbols: { type: boolean, default: true }
                excludeAmbiguous: { type: boolean, default: false }
              required: [ length ]
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  password: { type: string, example: "A8f!mZpQ1@tc" }
        '400':
          description: Validation error
        '422':
          description: Unprocessable
```

## 11. 驗收標準（Acceptance Criteria）

1. `length=6` 與 `length=64` 皆可正常回應（邊界）。
2. `length=5` 或 `65` 回傳 400 與明確訊息。
3. 預設未傳 `digits/symbols/excludeAmbiguous` 時，採預設值並成功回應。
4. `digits=true` 時，結果至少含 1 個數字；`symbols=true` 同理。
5. `excludeAmbiguous=true` 時，結果不包含易混淆字集合任一字元。
6. 產生時間（本機）平均 < 50ms。
7. 前端可一鍵複製，強度條會隨結果更新。

## 12. 測試案例（重點）

* **長度測試**：6、12、64、5、65。
* **類別測試**：

  * `digits=false, symbols=false` → 僅字母
  * `digits=true, symbols=false` → 含至少 1 數字
  * `digits=false, symbols=true` → 含至少 1 符號
  * `digits=true, symbols=true` → 皆至少 1
* **易混淆字**：`excludeAmbiguous=true` 多次產生 → 不含集合字元。
* **併發**：10/50 併發下回應皆 200 且不同字串。
* **安全**：日誌不輸出明文密碼。

（選用 JUnit 5 / MockMvc 撰寫單元測試與控制器整合測試。）

## 13. 專案結構（建議）

```
confidential-password-generator
├─ src/main/java/com/example/cpg/
│  ├─ controller/PasswordController.java
│  ├─ service/PasswordGeneratorService.java
│  ├─ service/PasswordGeneratorServiceImpl.java
│  ├─ dto/PasswordRequest.java
│  ├─ dto/PasswordResponse.java
│  ├─ domain/PasswordPolicy.java
│  ├─ advice/GlobalExceptionHandler.java
│  └─ CpgApplication.java
├─ src/main/resources/
│  └─ application.yml
├─ src/test/java/com/example/cpg/...
└─ frontend/
   └─ index.html
```

## 14. 安全與品質要求

* 使用 `SecureRandom`。
* 不記錄密碼；日誌中不得出現回傳值。
* 設定 CORS（若前端與 API 不同源）。
* 依需求加入簡易速率限制（反爬／濫用防護，選配）。

## 15. 部署與環境

* **建置**：`mvn clean package`
* **執行**：`java -jar target/cpg-1.0.0.jar`（預設埠 8080）
* **環境**：Java 17、Spring Boot 3.x
* **前端**：以靜態檔案佈署於同站 Nginx 或 Spring Boot `resources/static`（可將 `index.html` 放置於 `src/main/resources/static`）。

## 16. 後續延伸

* 加入「必含大寫/小寫」勾選與校驗。
* 多組一次產生（`count` 參數）。
* 下載為 CSV/文本。
* 密碼強度以熵值估算顯示。
* i18n 前端介面（中/英切換）。


