以下以本專案《In-Memory URL Shortener》為例，用**流程圖＋分層說明**快速梳理 Spring Boot 專案從「使用者操作 → 前端 → 後端 → 回應」的整體運作。內容涵蓋三條主流程：`POST /shorten`、`GET /r/{code}`、TTL 排程清理。

---

# 一、整體分層與請求生命週期（高層示意）

```
[Browser/UI]
   │  (Fetch)
   ▼
[Controller  (ShortenController)]  ← Validation / Mapping
   │
   ▼
[Service     (ShortenService)]     ← 業務規則、冪等、碰撞處理、TTL
   │
   ▼
[Store       (InMemoryStore)]      ← ConcurrentHashMap: urlToCode / codeToEntry
   │
   ▼
[Util        (CodeGenerator)]      ← Base62/Hash 產碼，碰撞重試
```

* **請求進入**：Spring MVC 透過 DispatcherServlet 將 HTTP 請求路由至對應 `@RestController` 方法。
* **驗證與轉換**：Controller 層做輸入驗證（Validation），將 JSON 轉為 DTO。
* **業務處理**：Service 層執行冪等檢查、產碼、TTL 計算與碰撞避讓。
* **資料存取**：Store 層操作 `ConcurrentHashMap`，保證併發下的一致性。
* **回應**：Controller 將結果物件序列化為 JSON，或回傳 302 轉址（含 Location 標頭）。

---

# 二、使用者操作到 API 的前端流程

```
[輸入 URL / 選 TTL] ──點擊「產生短連結」──►
  驗證（格式/必填） → Fetch POST /shorten JSON
       │
       └──錯誤→ 在表單下方顯示訊息（紅字）
成功回應（code/shortUrl/expiresAt）
       │
       ├─► 顯示短連結 + 複製到剪貼簿
       └─► 寫入 LocalStorage（最近 5 筆）
```

---

# 三、`POST /shorten`（縮網址）— 控制器到服務的主流程

## 3.1 流程圖（簡化）

```
[Controller: POST /shorten]
        │  1) 驗證請求：URL / TTL
        ▼
[ShortenService.shorten(url, ttl?)]
        │  2) 冪等：urlToCode 是否已存在？
        │     ├─ 存在 → 回傳既有 code（不更新 TTL）
        │     └─ 不存在 → 產生候選 code
        │
        │  3) 碰撞處理：
        │     while codeToEntry 存在且 url 不同：
        │         以 salt 再生 code
        │
        │  4) 寫入：
        │     urlToCode.put(url, code)
        │     codeToEntry.put(code, Entry{url, code, createdAt, expiresAt})
        ▼
[Controller 回應 201/200 + JSON]
```

## 3.2 關鍵點

* **Validation**：只接受 `http|https`；TTL 必須為正整數且未超過上限。
* **冪等**：以 `urlToCode` 先查，若存在直接回傳相同 `code`，**不刷新 TTL**。
* **碰撞處理**：`codeToEntry` 已被其他 URL 占用時，以 `salt` 疊代產新碼直到無衝突。
* **併發安全**：`ConcurrentHashMap` 搭配 `computeIfAbsent` 或小範圍鎖，確保在高併發下不會產生多組重覆映射。

---

# 四、`GET /r/{code}`（轉址）— 讀取與到期判斷流程

## 4.1 流程圖（簡化）

```
[Controller: GET /r/{code}]
        │  1) 依 code 查 codeToEntry
        │     ├─ 無 → 404 E4041_CODE_NOT_FOUND
        │     └─ 有 → 檢查 TTL
        │
        │  2) 若已過期：
        │       - 清除 codeToEntry / urlToCode
        │       - 回 404/410 E4101_CODE_EXPIRED
        │
        │  3) 未過期 → 回 302 Found
        │       Header: Location = entry.url
        ▼
[Browser 重導向至原網址]
```

## 4.2 關鍵點

* **HTTP 302**：以 `Location` 標頭指定原始 URL。
* **過期即清**：請求端觸發時，若已過期，立即做清理並回 404/410。
* **快取控制**：`Cache-Control: no-store` 避免中間層快取短碼轉址結果。

---

# 五、TTL 定期清理（@Scheduled）— 背景排程

## 5.1 流程圖（簡化）

```
[@Scheduled: 每 SWEEP_INTERVAL_SECONDS 觸發]
        │
        │  1) 掃描 codeToEntry：
        │     若 entry.expiresAt != null 且 now > expiresAt
        │         → remove(codeToEntry[code])
        │         → remove(urlToCode[entry.url])
        │
        ▼
[結束一次掃描]
```

## 5.2 關鍵點

* **主動回收**：減少過期遺留，控制記憶體成長。
* **延時視窗**：排程間隔與請求觸發清理共同作用，確保過期條目能被清除。
* **Clock 注入**（進階）：以 `Clock` 便於測試控制「現在」時間。

---

# 六、錯誤處理與回應格式（統一策略）

```
[Validation 錯誤] → 400 E4001_INVALID_URL / E4002_TTL_OUT_OF_RANGE
[找不到短碼]      → 404 E4041_CODE_NOT_FOUND
[已過期]          → 404/410 E4101_CODE_EXPIRED
[非預期錯誤]      → 500 E5001_INTERNAL_ERROR
```

* **前端行為**：接收 JSON 錯誤碼與訊息，顯示至表單下方或以 Toast 呈現。

---

# 七、資料流與併發安全（核心關係圖）

```
urlToCode: Map<String url, String code>
codeToEntry: Map<String code, Entry{url, code, createdAt, expiresAt}>

POST /shorten:
  1) 查 urlToCode[url] → 冪等
  2) 無 → 產碼（Hash→Base62）
  3) 檢查 codeToEntry[code]
       - 不存在 → 寫入兩張 Map
       - 存在且 url 不同 → salt 重試
```

* **一致性保證**：`urlToCode` 與 `codeToEntry` 需保持雙向一致；任何刪除都要同步兩張 Map。
* **臨界區**：以最小限度鎖保護「產碼→占位→寫入」流程，避免寫入競爭。

---

# 八、前端交互流程（使用者視角）

```
使用者輸入 URL/選 TTL
   │
   ├─ 前端檢查（必填、協定、TTL）→ 不通過：顯示錯誤訊息
   │
   └─ 通過 → fetch('/shorten', {...})
            │
            ├─ 200（已存在）/201（新建）
            │     ├─ 顯示短連結
            │     ├─ 一鍵複製
            │     └─ 寫入 LocalStorage（最多保留 5 筆）
            │
            └─ 4xx/5xx → 解析錯誤碼，提示使用者
```

---

# 九、端對端（E2E）視角的三條關鍵情境

1. **建立短鏈成功**
   `POST /shorten` → 201 + `{code, shortUrl, expiresAt}` → UI 顯示並可複製

2. **冪等重複縮短**
   `POST /shorten`（相同 URL）→ 200 + 舊 `{code, expiresAt}` → UI 視同已存在

3. **轉址或過期**
   `GET /r/{code}` →

* 未過期：302 + `Location: 原網址`
* 已過期 / 不存在：404/410 + 錯誤碼，並同步清理 Map

---

# 十、落地建議（實作順序）

1. **Model/Store/Util**：`Entry`、`InMemoryStore`、`CodeGenerator`（含 Base62、salt 重試）
2. **Service**：冪等、TTL、碰撞處理、`Clock` 注入
3. **Controller**：`POST /shorten`、`GET /r/{code}`，Validation 與錯誤對應
4. **Scheduled**：TTL 清理排程
5. **前端頁面**：表單、驗證、Fetch、結果呈現、LocalStorage
6. **測試**：單元測試（產碼/TTL/冪等/碰撞）、E2E（建立/重建/轉址/過期）

---

