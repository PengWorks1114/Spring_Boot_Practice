// 傳案名稱有更改

# Day 2｜回聲與時間伺服器：基本設計書（含前端介面）


## 1. 目的與範圍

* **目的**：透過兩個極小而完整的端點，練習 Request/Response、參數驗證、錯誤處理與前後端串接。
* **範圍**：

    * 後端：Spring Boot REST API（`/echo`, `/now`），加入 Bean Validation 與全域例外處理。
    * 前端：單一 HTML（Bootstrap）+ 原生 JS 範例頁，提供測試表單與結果顯示。
    * 文件：OpenAPI 規格、驗收條件與測試案例。

---

## 2. 系統構成與技術

* **後端**：Java 17、Spring Boot 3.x、spring-boot-starter-web、spring-boot-starter-validation、springdoc-openapi。
* **前端**：HTML + Bootstrap 5 + 原生 fetch。
* **時區**：以 `java.time.ZoneId` 驗證；若未提供 `tz`，預設 `Asia/Tokyo`。
* **錯誤格式**：RFC 7807 風格（Problem Details）或等價自訂 JSON。

---

## 3. 端點規格（API Spec）

### 3.1 POST `/echo`

* **說明**：回傳原文內容與字數。
* **Request Body（JSON）**：

  ```json
  {
    "text": "Hello world"
  }
  ```
* **驗證規則**：

    * `text` 不可為 `null`。
    * `text` 去除前後空白後不得為空字串。
    * 長度上限預設 2,000 字元（可於設定檔調整）。
* **200 OK（JSON）**：

  ```json
  {
    "original": "Hello world",
    "length": 11
  }
  ```

    * `length` 計算以 Unicode code point 為準（避免 emoji/代理對誤差）。
* **400 Bad Request（JSON, Problem Details）**：

  ```json
  {
    "type": "about:blank",
    "title": "Bad Request",
    "status": 400,
    "detail": "text must not be blank",
    "errors": [
      {"field":"text","message":"must not be blank"}
    ],
    "timestamp": "2025-08-22T04:20:00Z",
    "traceId": "a1b2c3..."
  }
  ```

### 3.2 GET `/now`

* **說明**：回傳指定時區的當前時間。
* **Query Parameters**：

    * `tz`（選填）：IANA 時區字串（例如 `Asia/Tokyo`, `UTC`, `Europe/Paris`）。
* **行為**：

    * 未提供 `tz` → 預設 `Asia/Tokyo`。
    * 提供無效 `tz` → 400。
* **200 OK（JSON）**：

  ```json
  {
    "zone": "Asia/Tokyo",
    "instant": "2025-08-22T04:20:00Z",
    "localDateTime": "2025-08-22T13:20:00",
    "offset": "+09:00",
    "epochMilli": 1766444400000
  }
  ```
* **400 Bad Request（JSON）**（無效 `tz`）：

  ```json
  {
    "type": "about:blank",
    "title": "Bad Request",
    "status": 400,
    "detail": "Invalid time zone: Asia/Tyoko",
    "errors": [],
    "timestamp": "2025-08-22T04:20:01Z",
    "traceId": "d4e5f6..."
  }
  ```

---

## 4. 結構設計（後端）

### 4.1 專案包結構

```
com.example.day2
 ├─ controller
 │   ├─ EchoController.java
 │   └─ TimeController.java
 ├─ dto
 │   ├─ EchoRequest.java
 │   └─ EchoResponse.java
 │   └─ NowResponse.java
 ├─ exception
 │   ├─ GlobalExceptionHandler.java   // @ControllerAdvice
 │   └─ ApiError.java                 // Problem Details
 ├─ service
 │   ├─ EchoService.java
 │   └─ TimeService.java
 ├─ util
 │   └─ TextLength.java               // Unicode 長度工具
 └─ Day2Application.java
```

### 4.2 DTO 定義（重點欄位）

* `EchoRequest`

    * `String text`（`@NotNull`、自訂 `@NotBlankTrimmed`、`@Size(max=2000)`）
* `EchoResponse`

    * `String original`、`int length`
* `NowResponse`

    * `String zone`、`String instant`（ISO-8601 UTC）、`String localDateTime`、`String offset`、`long epochMilli`

### 4.3 驗證與錯誤處理

* 使用 `jakarta.validation` 驗證 Body/Query。
* 全域例外處理：

    * `MethodArgumentNotValidException` → 彙整欄位錯誤至 `errors[]`。
    * `ConstraintViolationException`（Query 參數）→ 轉 Problem JSON。
    * `DateTimeException`（無效時區）→ 轉 400。
    * 其他未捕捉 → 500，隱藏細節，保留 `traceId`。

---

## 5. 前端介面（單檔 HTML）

### 5.1 需求

* 一頁含兩卡片：

    1. Echo 測試：文字輸入、送出、顯示 original/length。
    2. Now 測試：tz 輸入（含下拉常用選單）、顯示 zone/instant/localDateTime/offset。
* 顯示錯誤訊息與 400 內容。
* 使用 Bootstrap 5、原生 `fetch`。

### 5.2 範例頁（可直接使用）

```html
<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Day 2｜Echo & Time Client</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">
<div class="container py-4">
  <h1 class="mb-4">Day 2｜Echo & Time Client</h1>

  <!-- Echo -->
  <div class="card mb-4">
    <div class="card-header fw-bold">/echo 測試</div>
    <div class="card-body">
      <div class="mb-3">
        <label class="form-label">輸入文字</label>
        <textarea id="echoText" class="form-control" rows="3" placeholder="輸入任意文字"></textarea>
      </div>
      <button id="btnEcho" class="btn btn-primary">送出</button>
      <pre id="echoResult" class="mt-3 bg-body-tertiary p-3 border rounded" style="white-space:pre-wrap"></pre>
    </div>
  </div>

  <!-- Now -->
  <div class="card">
    <div class="card-header fw-bold">/now 測試</div>
    <div class="card-body">
      <div class="row g-2 align-items-end">
        <div class="col-sm-6">
          <label class="form-label">IANA 時區（選填）</label>
          <input id="tz" class="form-control" placeholder="Asia/Tokyo" list="tzList">
          <datalist id="tzList">
            <option value="Asia/Tokyo"></option>
            <option value="UTC"></option>
            <option value="Europe/Paris"></option>
            <option value="America/Los_Angeles"></option>
            <option value="Asia/Taipei"></option>
          </datalist>
        </div>
        <div class="col-auto">
          <button id="btnNow" class="btn btn-success">取得時間</button>
        </div>
      </div>
      <pre id="nowResult" class="mt-3 bg-body-tertiary p-3 border rounded"></pre>
    </div>
  </div>
</div>

<script>
const apiBase = ""; // 同域部署時留空；跨域時填入 http://localhost:8080 等

async function postEcho() {
  const text = document.getElementById('echoText').value;
  const resBox = document.getElementById('echoResult');
  resBox.textContent = "執行中…";
  try {
    const resp = await fetch(`${apiBase}/echo`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ text })
    });
    const json = await resp.json();
    resBox.textContent = JSON.stringify(json, null, 2);
  } catch (e) {
    resBox.textContent = `發生錯誤：${e}`;
  }
}

async function getNow() {
  const tz = document.getElementById('tz').value.trim();
  const resBox = document.getElementById('nowResult');
  resBox.textContent = "執行中…";
  const url = tz ? `${apiBase}/now?tz=${encodeURIComponent(tz)}` : `${apiBase}/now`;
  try {
    const resp = await fetch(url);
    const json = await resp.json();
    resBox.textContent = JSON.stringify(json, null, 2);
  } catch (e) {
    resBox.textContent = `發生錯誤：${e}`;
  }
}

document.getElementById('btnEcho').addEventListener('click', postEcho);
document.getElementById('btnNow').addEventListener('click', getNow);
</script>
</body>
</html>
```

---

## 6. 後端範例（核心程式骨架）

### 6.1 EchoController / Service（節錄）

```java
@RestController
@RequiredArgsConstructor
public class EchoController {
  private final EchoService echoService;

  @PostMapping("/echo")
  public ResponseEntity<EchoResponse> echo(@Valid @RequestBody EchoRequest req) {
    return ResponseEntity.ok(echoService.echo(req));
  }
}

@Service
public class EchoService {
  public EchoResponse echo(EchoRequest req) {
    final String original = req.getText();
    final int length = original.codePointCount(0, original.length());
    return new EchoResponse(original, length);
  }
}
```

```java
@Getter @Setter
public class EchoRequest {
  @NotNull(message = "text must not be null")
  @Size(max = 2000, message = "text too long")
  private String text;

  @AssertTrue(message = "text must not be blank")
  public boolean isNotBlankAfterTrim() {
    return text != null && !text.trim().isEmpty();
  }
}
```

### 6.2 TimeController / Service（節錄）

```java
@RestController
@RequiredArgsConstructor
public class TimeController {
  private final TimeService timeService;

  @GetMapping("/now")
  public ResponseEntity<NowResponse> now(@RequestParam(required = false) String tz) {
    return ResponseEntity.ok(timeService.now(tz));
  }
}

@Service
public class TimeService {
  public NowResponse now(String tz) {
    final String zoneId = (tz == null || tz.isBlank()) ? "Asia/Tokyo" : tz.trim();
    try {
      ZoneId zone = ZoneId.of(zoneId);
      Instant instant = Instant.now();
      ZonedDateTime zdt = instant.atZone(zone);
      return new NowResponse(
        zone.getId(),
        instant.toString(),
        zdt.toLocalDateTime().toString(),
        zdt.getOffset().toString(),
        instant.toEpochMilli()
      );
    } catch (DateTimeException ex) {
      throw new IllegalArgumentException("Invalid time zone: " + zoneId);
    }
  }
}
```

### 6.3 全域例外處理（節錄）

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(MethodArgumentNotValidException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ApiError handleValidation(MethodArgumentNotValidException ex) {
    List<ApiError.FieldError> fieldErrors = ex.getBindingResult().getFieldErrors().stream()
      .map(fe -> new ApiError.FieldError(fe.getField(), fe.getDefaultMessage()))
      .toList();
    return ApiError.badRequest("Validation failed", fieldErrors);
  }

  @ExceptionHandler(ConstraintViolationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ApiError handleConstraint(ConstraintViolationException ex) {
    List<ApiError.FieldError> errors = ex.getConstraintViolations().stream()
      .map(v -> new ApiError.FieldError(v.getPropertyPath().toString(), v.getMessage()))
      .toList();
    return ApiError.badRequest("Constraint violation", errors);
  }

  @ExceptionHandler(IllegalArgumentException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public ApiError handleIllegalArgument(IllegalArgumentException ex) {
    return ApiError.badRequest(ex.getMessage(), List.of());
  }

  @ExceptionHandler(Exception.class)
  @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
  public ApiError handleOthers(Exception ex) {
    return ApiError.internalServerError("Unexpected error");
  }
}
```

---

## 7. 設定與文件

### 7.1 `application.yml`（重點）

```yaml
server:
  port: 8080

app:
  echo:
    max-length: 2000

springdoc:
  api-docs:
    enabled: true
  swagger-ui:
    enabled: true
```

### 7.2 OpenAPI（縮略示意）

```yaml
openapi: 3.0.3
info:
  title: Day 2 Echo & Time API
  version: 1.0.0
paths:
  /echo:
    post:
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [text]
              properties:
                text:
                  type: string
                  maxLength: 2000
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  original: { type: string }
                  length: { type: integer }
        '400':
          $ref: '#/components/responses/BadRequest'
  /now:
    get:
      parameters:
        - in: query
          name: tz
          required: false
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  zone: { type: string }
                  instant: { type: string, format: date-time }
                  localDateTime: { type: string }
                  offset: { type: string }
                  epochMilli: { type: integer, format: int64 }
        '400':
          $ref: '#/components/responses/BadRequest'
components:
  responses:
    BadRequest:
      description: Bad Request
      content:
        application/json:
          schema:
            type: object
            properties:
              type: { type: string }
              title: { type: string }
              status: { type: integer }
              detail: { type: string }
              errors:
                type: array
                items:
                  type: object
                  properties:
                    field: { type: string }
                    message: { type: string }
              timestamp: { type: string, format: date-time }
              traceId: { type: string }
```

---

## 8. 驗收條件（Acceptance Criteria）

1. **/echo**

    * `POST /echo` 傳入正常字串 → 回傳 `original` 與正確 `length`（emoji、CJK 能正確計數）。
    * `text` 為 `null`、空白或只含空白 → 400 並包含欄位錯誤訊息。
    * 超過 2000 字元 → 400。
2. **/now**

    * `GET /now` 不帶 `tz` → `zone=Asia/Tokyo` 且時間與系統相符（±1 秒）。
    * `GET /now?tz=UTC` → `offset=+00:00`。
    * 無效時區 → 400，`detail` 說明無效時區值。
3. **文件與 UI**

    * Swagger UI 可正常開啟並測試。
    * 前端頁面能以 fetch 串接兩端點，顯示成功與錯誤結果。
4. **錯誤處理**

    * 所有 400/500 都輸出一致 Problem JSON，包含 `timestamp` 與 `status`。

---

## 9. 測試設計（重點案例）

### 9.1 單元測試（JUnit + MockMvc）

* `/echo`

    * 正常字串 `"Hello"` → `length=5`
    * CJK `"你好"` → `length=2`
    * Emoji `"👨‍👩‍👧‍👦"`（家庭合字）→ `length` 以 code point 計；可加註說明與期望值
    * `null`、`"   "`、超長字串 → 400
* `/now`

    * 空 `tz`、`Asia/Tokyo`、`UTC` → 檢查 `zone` 與 `offset`
    * 無效 `tz=Asia/Tyoko` → 400

### 9.2 API 測試（Postman/Rest Client）

* 針對上述案例建立 collection，並驗證狀態碼與關鍵欄位。

---

## 10. 非功能性需求

* **效能**：單次請求 < 50ms（本機）。
* **安全**：接受 `application/json`；拒絕非 JSON Content-Type 的 `/echo` 請求（415）。
* **可維護性**：服務與驗證邏輯分層；錯誤處理集中於 `@ControllerAdvice`。
* **可觀測性**：在 `ApiError` 中輸出 `traceId`（可整合 `Slf4j MDC`）。

---

## 11. 延伸與加分項

* **時區清單端點**：`GET /zones` 回傳常見 IANA 時區陣列，前端 datalist 自動帶入。
* **i18n**：錯誤訊息國際化（`messages_zh_TW.properties`）。
* **CORS**：若前後端分離，於 `CorsConfiguration` 開放測試來源。
* **Docker**：提供 `Dockerfile` 與 `compose.yaml`。

---

## 12. 建置與啟動（概要）

1. 新增依賴：

    * `spring-boot-starter-web`, `spring-boot-starter-validation`, `org.springdoc:springdoc-openapi-starter-webmvc-ui`
2. 啟動 `Day2Application`，瀏覽：

    * Swagger UI：`/swagger-ui/index.html`
    * 前端測試頁：`/client/day2.html`（可放 `src/main/resources/static`）

---

## 13. 交付物

* 後端原始碼（含測試）。
* `application.yml` 與 OpenAPI 產出。
* `static/day2.html` 前端測試頁。
* Postman Collection（選配）。
